---
layout: post
title: "一个shell小脚本: 代码行统计脚本"
description: ""
category: 程序设计
subtitle:
author: "fishcried"
header-img: "img/bg/home-bg.jpg"
tags: [shell,代码行统计]
---

在电脑的bin文件夹里翻出来的,用于统计代码行数.支持c/shell/perl/python.很早之前做的半成品，放在这鞭策自己待它日完善，或者重写吧。

主要功能:

1. 分类型统计文件个数
2. 统计各个文件的有效代码行数
	+ 空行不算
	+ 注释不算(主要就是过滤注释)

当初写这个东西的原因或者说需求有两个:

- 一个是同学boss留给他的小case，而且有一个不公开的**crazy**测试文件，就是代码参杂了各种注释，代码变形等，出于挑战就也跟着研究了一下。
- 看一些项目源码，想有个总体的了解，项目的有效代码到底是多少。或者换一种表达方式，我比较想通过统计的方式，看一下项目中。空行，注释，有效代码的比例到底是怎样的，哎呀，好像涉及到了代码风格.

	#!/bin/bash
	
	#
	# file:CLcounter.sh
	#
	# func: count .c/.h/shell/perl/python files lines
	# version: 1.1
	# modified by fishcried at  Wed Jul 25 22:41:30 CST 2012
	
	# level deepth of recursive
	# default is null
	LEVEL=""
	# the work dir
	DEST_DIR=
	
	#tmpfile contants files' name 
	TMPFILE=/tmp/tmpfile.$$
	
	#XXX_FILES the total numbers  of XXX files
	#XXX_LINES the total lines of all the XXX files 
	C_FILES=
	C_LINES=
	
	H_FILES=
	H_LINES=
	
	SHELL_FILES=
	SHELL_LINES=
	
	PERL_FILES=
	PERL_FILES=
	
	PYTHON_FILES=
	PYTHON_LINES=
	
	#
	# print the usage of C_LINES
	# 
	usage(){
	#TODO: the usage which had been used is not nice!
	# The more efficitive maybe like this:
	# clcounter [dir] [-l [level]] [-t filetype]
	#
		cat <<EOF
	        Usage:\t clcounter -d dir -[r [level]]
		
		Options:
			-d dir which to count
			-r [level] recurise level, default it's infinity
	EOF
	}
	
	is_c_file(){
		 [ $# -eq 1 ] && [ ${1##*\.} = "c" ]
	
	}
	is_h_file(){
		 [ $# -eq 1 ] && [ ${1##*\.} = "h" ]
	}
	is_shell_file(){
		[ $# -eq 1 ] &&   file "$1" | grep -F 'shell script' >/dev/null 
	}
	is_perl_file(){
		[ $# -eq 1 ] &&   file "$1" | grep -F 'perl script' >/dev/null 
	}
	is_python_file(){
		[ $# -eq 1 ] &&   file "$1" | grep -F 'python script' >/dev/null 
	}
	count_c_file(){
			cat "$@" |
			sed -r -e '/^[[:space:]]*\/\*/,/\*\/[[:space:]]*$/d' \
			-e '/^[[:space:]]*\/\//d' \
			-e '/^[[:space:]]*$/d' | 
			wc -l
	}
	count_h_file(){
		count_c_file "$@"
	}
	count_shell_file(){
		cat "$@" |
		sed -re '1s/#/!/' \
		    -e '/^[[:space:]]*#/d' \
		    -e '/^[[:space:]]*$/d' |
		wc -l
	}
	count_perl_file(){
		count_shell_file "$@"
	}
	count_python_file(){
			cat "$@" |
			sed -e '1s/#/!/' |
			sed -r -e '/^[[:space:]]*"""/,/"""[[:space:]]*$/d' \
		               -e '/^[[:space:]]*#/d' \
			       -e '/^[[:space:]]*$/d' | 
			wc -l
	}
	
	#
	# main
	# 
	
	#FIXME: when something was wrong, it could not delte the temp file.
	trap $(rm -f $TMPFILE >/dev/null 2>&1) 2  EXIT ERR INT
	
	# check the arguments
	[ $# -lt 2 ] && { # the number of  arguments  at least 2
	        usage
	        exit 2
	}
	# prase the arguments
	while [ $# -gt 0 ]
	do
	        case "$1" in
	                -d)  if [ -z "$2" ];then
	                        usage
	                        exit 2
	                     elif [ ! -e "$2" -o ! -d "$2" ];then
	                        echo "$2 must be exist and be a diretory"
	                        exit 2
	                     else
	                        DEST_DIR=$2
	                        shift 2
	                     fi
	                        ;;
	                -r)    if [ -n "$2" ];then
	                                case "$2" in
	                                       [1-9]*)
	                                                LEVEL=$2
	                                                shift 2
	                                                ;;
	                                        *)
	                                                echo "level must be integer number"
	                                                exit 2
	                                                ;;
	                                esac
	                        else
	                                LEVEL=1
	                                shift 
	                        fi
	                                ;;
	                *)
			usage
			exit 1
	                        ;;
	        esac
	done
	# find all the reguler files in the dir 
	if [ -z "$LEVEL" ]; then
		find $DEST_DIR -type f -print > $TMPFILE 2>/dev/null
	else
		find $DEST_DIR -maxdepth $LEVEL -type f -print > $TMPFILE 2>/dev/null
	fi
	
	# classiry the files and count the lines
	while read file
	do
		if is_c_file "$file"; then
			lines=$(count_c_file $file)
			C_LINES=$(($C_LINES + $lines))
			C_FILES=$(($C_FILES + 1))
		elif is_h_file "$file"; then
			lines=$(count_h_file $file)
			H_LINES=$(($H_LINES + $lines))
			H_FILES=$(($H_FILES + 1))
		elif is_shell_file "$file"; then
			lines=$(count_shell_file $file)
			SHELL_LINES=$(($SHELL_LINES + $lines))
			SHELL_FILES=$(($SHELL_FILES + 1))
		elif is_perl_file "$file"; then
			lines=$(count_perl_file $file)
			PERL_LINES=$(($PERL_LINES + $lines))
			PERL_FILES=$(($PERL_FILES + 1))
		elif is_python_file "$file"; then
			lines=$(count_python_file $file)
			PYTHON_LINES=$(($PYTHON_LINES + $lines))
			PYTHON_FILES=$(($PYTHON_FILES + 1))
		else
			continue
		fi
	done < $TMPFILE
	
	rm $TMPFILE
	
	# print the result
	printf "file type\tfile numbers\ttotal lines\n"
	printf "%-9s\t%-12d\t%-12d\t\n" ".c" $C_FILES $C_LINES
	printf "%-9s\t%-12d\t%-12d\t\n" ".h" $H_FILES $H_LINES
	printf "%-9s\t%-12d\t%-12d\t\n" "perl" $PERL_FILES $PERL_LINES
	printf "%-9s\t%-12d\t%-12d\t\n" "shell" $SHELL_FILES $SHELL_LINES
	printf "%-9s\t%-12d\t%-12d\t\n" "python" $PYTHON_FILES $PYTHON_LINES
	exit 0

# 修改记录

|Why | Who | When |
|----|-----|------|
|整理旧文档|fishcired|2014-07-01|
|调整了格式|fishcired|2014-08-06 |
